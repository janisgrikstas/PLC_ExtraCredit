Introduction

My new programming language is designed to be a simple and intuitive tool for students to use when learning the ART of programming. It features a clean syntax library, making it easy to write programs that are both efficient and readable for beginners. While learning how to code, I had a hard time visualizing what the code was doing, based off of abstract keywords and method calls, some of which i had first heard of in that class. This program's simplicity seeks to solve that by using plain english and a more logical why of describing and declaring language actions.


Some of the notable features of the language include:

Support for a variety of data types, including integer numbers, real numbers, strings, and booleans, with intuitive declarations.
A wide range of operators for performing arithmetic, logical, and assignment operations
Control structures for conditional execution and looping
Built-in support for defining and calling functions
//A rich standard library of built-in functions and modules for common tasks
With these features, my programming language is well-suited for a variety of levels of learning, from beginners to intermediate to programmers dusting off their skills.

real_lit ->"[+-]?\\d+\\.\\d+"
natural_lit -> "[+-]?\\d+"
bool_lit -> “true” | “false”
char_lit -> "'(\\\\[\\s\\S]|[^'])'"
string_lit -> "\"(\\\\[\\s\\S]|[^\"])*\""
symbol -> ( // opening parentheses, breaking precedence for mathematical operations
symbol -> ) // closing parentheses 
symbol -> { // opening bracket
symbol -> } // closing bracket
symbol -> ; // statement ender
symbol -> , // parameter seperator
identifier -> [A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z][A-Za-z]?[A-Za-z]?
operator -> + //addition 
operator -> - //subtraction
operator -> * //multiplication
operator -> / //division
operator ->  = //assignment
bool_operator -> and // && operator **
bool_operator -> or // || operator **
bool_operator -> is= // is equal to (==) **
bool_operator -> < // less that
bool_operator -> > // greater than
bool_operator -> <= // less than or equal to
bool_operator -> >= // greater than or equal to
bool_operator -> not= // not equal to **
key word -> `dothiswhile` while loop  **
key word -> `begin` //program starter
key word -> `isthistrue` //switch
key word -> `ifnot` //else
declaration_keywords -> `number` //int
declaration_keywords -> `word` //string
declaration_keywords -> `yesorno` //boolean
declaration_keywords -> `decimal` //double

<program> -> begin<stmt_list>
<stmt_list< -> <stmt> ; | <stmt> ; <stmt_list>
<stmt> —> <var_declaration> | <func_declaration> | <assignment> | <expression> | <while_loop> | <switch> | <block>
<block> -> `{` <stmt> `}`
<while_loop> -> `dothiswhile(` <and> `)` <block> 
<switch> -> `isthistrue (` <and> `)` <block> [`ifnot` <block>]
<expression> -> <term> (`*`| `/` | `%` ) <term> | <term>
<term> -> <factor> (`+`| `-`) <factor> | <factor>
<factor> -> identifier |`number`|`decimal` |`word` | `yesorno` 
<var_declaration> -> declaration_keyword identifier  `;`
<assignment> -> identifier `=` <expression> `;`
<func_declaration> -> `function` identifier `(` <parameter> `)` <block>
<and> -> <or> `and` <or> | <or>
<or> -> <check_if_equal>  `or` <check_if_equal> | <check_if_equals>
<check_if_equal> -> <check_value> (`not=`|`is=`) <check_value> | <check_value>
<check_value> -> <boolean_expression> (`<=`|`>=`|`<`|`>`) <boolean_expression> | <boolean_expression>
<boolean_expression> -> <boolean_term> (`*`|`/`|`%`) <boolean_term> | 
<boolean_term> -> <boolean_factor> (`+`|`-`) <boolean_factor> | <boolean_factor>
<boolean_factor>-> identifier |`natural_lit`|`bool_lit` |`char_lit` | `string_lit` | `real_lit`


1)token.java

2)compiler.java

3)lexer.java

4)parser.java


Denotational semantics for selected statements


<switch> -> `isthistrue (` <and> `)` <block> [`ifnot` <block>]
M_s(ifthistrue(<and>) <block>[1] ifnot <block>[2], s)
		if M_b(<and>, s) == error
		return error
		if M_b(<and>, s)
			return M_block(<block>[1], s)
		else return M_block(<block>[2], s)


<while_loop> -> `dothiswhile(` <and> `)` <block> 
M_while (dothiswhile (<and>) <block> =, s)
		if M_b(<and>, s) == error
		return error
		if M_b(<and>, s)
			if M_b(<stmt>, s) ==error
				error
			else s = M_s(<block>, s)
			M_while(dothiswhile (<and>) <block> =, s)		
		else
		return s

<expression> -> <term> (`*`| `/` | `%` ) <term> | <term>
M_e (<expression>, s) == switch(<expression>)
	case <term>[1] *  <term>[2]:
		if M_e(<expression>.term[1], s) == error || M_e(<expression>.term[2], s) == error 
		return error
		if(M_t(<term[1]>).type != M_t(<term[2]>).type)
		return error		
		else return M_t(<term[1]>, s) * M_t (<term[2]>, s)
	case <term>[1] /  <term>[2]:
		if M_e(<expression>.term[1], s) == error || M_e(<expression>.term[2], s) == error 
		return error
		if(M_t(<term[1]>).type != M_t(<term[2]>).type)
		return error		
		else return M_t(<term[1]>, s) / M_t (<term[2]>, s)
	case <term>[1] %  <term>[2]:
		if M_e(<expression>.term[1], s) == error || M_e(<expression>.term[2], s) == error 
		return error
		if(M_t(<term[1]>).type != M_t(<term[2]>).type)
		return error		
		else return M_t(<term[1]>, s) * M_t (<term[2]>, s)


<term> -> <factor> (`+`| `-`) <factor> | <factor>
M_t (<term> ,s )==switch(<term>)
	case <factor>[1] +  <factor>[2]:
		if M_t(<term>.factor[1], s) == error || M_t(<term>.factor[2], s) == error 
		return error
		if(M_t(<factor[1]>).type != M_t(<factor>[2]>).type)
		return error
		else return M_f (<factor[1]>, s) + M_f (<factor[2]>, s)
	case <factor>[1] -  <factor>[2]:
		if M_t(<term>.factor[1], s) == error || M_t(<term>.factor[2], s) == error 
		return error
		if(M_f(<factor[1]>).type != M_f(<factor[2]>).type)
		return error
		else return M_f (<factor[1]>, s) - M_f (<factor[2]>, s)



<factor> -> identifier | `number`| `decimal` | `word` | 
M_f(<factor>, s) == switch (<factor>)
	case <var> if VARMAP(<var>, s)==undefined
		then error
		else return VARMAP (<var>, s)
	case <int_lit>
		return <int_lit>.value
	case <real_lit>
		return <real_lit>.value
	case <word>
		return <word>.value


<and> -> <or> `and` <or> | <or>
M_bool_e (<bool_expression>, s) == switch(<bool_expression>)
	case <boolterm>[1] *  <boolterm>[2]:
		if M_bool_e(<bool_expression>.term[1], s) == error || M_e(<bool_expression>.term[2], s) == error 
		return error		
		else return M_bool_t(<bool_term[1]>, s) * M_bool_t (<bool_term[2]>, s)
	case <boolterm>[1] /  <boolterm>[2]:
		if M_bool_e(<bool_expression>.term[1], s) == error || M_e(<bool_expression>.term[2], s) == error 
		return error		
		else return M_bool_t(<bool_term[1]>, s) / M_bool_t (<bool_term[2]>, s)
	case <boolterm>[1] %  <boolterm>[2]:
		if M_bool_e(<bool_expression>.term[1], s) == error || M_e(<bool_expression>.term[2], s) == error 
		return error		
		else return M_bool_t(<bool_term[1]>, s) % M_bool_t (<bool_term[2]>, s)
	case <boolterm>
		if M_bool_e(<bool_expression>.term, s) == error  
		return error		
		else return M_bool_t(<bool_term>, s)



M_bool_t (<bool_term> ,s )==switch(<term>)
	case <bool_factor>[1] +  <bool_factor>[2]:
		if M_bool_t(<term>.factor[1], s) == error || M_bool_t(<term>.factor[2], s) == error 
		return error
		if(M_bool_t(<factor[1]>).type != M_bool_t(<factor>[2]>).type)
		return error
		else return M_bool_f (<bool_factor[1]>, s) + M_bool_f (<bool_factor[2]>, s)
	case <bool_factor>[1] -  <factor>[2]:
		if M_bool_t(<term>.factor[1], s) == error || M_bool_t(<term>.factor[2], s) == error 
		return error
		if(M_bool_t(<factor[1]>).type != M_bool_t(<factor>[2]>).type)
		return error
		else return M_bool_f (<bool_factor[1]>, s) - M_bool_f (<bool_factor[2]>, s)
	case <bool_factor>
		return M_bool_f(<bool_factor>, s)


<boolean_factor>-> identifier | <yesorno>
M_bool_f(<fbool_actor>, s) == switch (<factor>)
	return s




